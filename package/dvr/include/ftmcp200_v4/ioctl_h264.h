#ifndef __IOCTL_H264_H_#define __IOCTL_H264_H_//================Change log===================///*Version 2.0: Upgrade to GM Version, add check version typeVersion 2.1: Dynamic SPS/PPS,intra supportVersion 2.2: Update for Synchronization issueVersion 2.3: Update for Synchronization issue 2Version 2.4: Update for Multi Slice and mp4 2D encodingVersion 2.5: 1. Update for output multiple format and input MP4 and H264 2D             2. Update for output bitstream syntax                The original BS => IDR_I, nonIDR_P, nonIDR_P...,nonIDR_I,nonIDR_P...                The new BS      => IDR_I, nonIDR_P, nonIDR_P...,       IDR_I,nonIDR_P...             3. Update increasing rule of the syntax element frame_num, the number of IDR                 is always zero.     Version 2.6: 1. support raster scan 420 planar format for input image at h264 encoder driver  			 2. support raster scan 422 packed format for input image at h264 encoder driver  			 3. support decoder crop function when frame buffer width is smaller than video width			    and the crop width is equal to frame buffer width			 4. add new IOCTL to get only SPS+PPSVersion 2.7:			1. Force to encode one frame as one slice at encoder driver			2. Fix decoder crop function			3. Fix forever-loop at decoder when bitstream is not enought			4. Modify schedule timeout when encoding.			Version 2.8:			Encoder:			1. Performance enhance:SystemInfo buffer always use cacheable region						Decoder			1. Prevent system crash from sps or pps not existing			2. Monitor sync time out for parsing header			Version 3.0:			1. Version update to v3.00 for H264 Encoder/Decoder			2. Support  both Videograph and IOCTL flow			3. Move source tree to /arm-linux-2.6/module/			4. VG mode support motion dection.Version 3.1:			1.09.11.18 timing measurement modified for decoder				2.Support decoder FIQ function(prevent mcp220 access forbidden memory region cause by bit-stream error )					3.VG Mode: Check Handler NULL when begain to process job			4.VG Mode: Allocate memory when the channel first be Initial, than not to release, unless module be removed.			5.Reference different frammap function when IOCLT mode and VG mode			6.VG Mode: move rate control module to DVR driver layer			7.Process IRQ after timeput			8.Process un-expect interrupt			9.VG mode: use memory pool to share reference and reconstructed frame buffer for each channel			10.VG mode: Balance job Version 3.2 			1.2010.01.08 Support 2x 4x FWD function in IOCTL mode			2.Remove _fast_fwd_ctl_ define			3.VG mode: Set Buf-size to bs_length and set valid bitstream number to 0xffff to avoid if the two register in same value, the irq will not happened.			4.VG mode: Remove Balance job 			5.IOCLT mode support 16+1(mega pixel)ch decoderVersion 3.3			1.IOCTL mode support ForceNonRef feature.Version 4.10			Encoder:				1. reduce AP to IOCTL parameter 				2. fixed bug for VUI aspect ratio				3. fixed bug of POC when IDR				4. fixed bug for multislice				5. reduce memory usage (, using common reconstructed frame buffer).				6. fixed bug of NAL header error when all IDR			Decoder:				1. reduce AP to IOCTL parameter 				2. reduce memory usage (, using common reconstructed frame buffer).Version 4.11			Encoder:				1. fixed bug when force intra each frameVersion 4.12			Encoder:				1. fixed bug when using FAVC_IOCTL_GET_SYSINFO at 8185v2/8181				2. fixed bug when p-frame comes first after reinit				3. fixed bug of wrong sar_height in VUIVersion 4.13			Decoder:				1. More robust when trailing bit is illegal				2. fixed bug when some frames are lost.Version 4.14			Decoder:				1. fixed bug of access illegal area at FIQ mode for 8181/8185				2. support "frame_crop_bottom_offset" not equal to 0Version 4.15			Decoder:				1. fixed bug of access illegal area at FIQ mode for 8181/8185				2. Support only decoding part of frame, which is encoded in multiple slices.Version 4.16			Decoder:				1. Support only decoding part of frame, immediately valid when full to partial;				   Instead of waiting for next I-frame when partial to full.			Encoder:				1. Support ROI start position may not align at 16 pixels				   a. should be align at (hor. = 8 pxls, ver. = 2 pxls) when input img format is RASTER_SCAN_420				   b. should be align at (hor. = 2 pxls, ver. = 1 pxls) when input img format is RASTER_SCAN_422Version 4.17			Encoder:				1. Support one interface to get slice offset (to reduce parsing effort for AP)Version 4.18 			Fixed bug of may encoding incorrect image at slice boundary when p-frame			Decoder:				1. Support overlap slices			Encoder:				1. Support overlap 1 MB row between slicesVersion 4.19            Encoder:                1. Support encode one frame as two half frames                2. Support to set video_full_range_flag of VUI                3. Support addptive profile level setting depend on resolution            Decoder:                1. Support decode two half frame or the first of two half frames at one frame bufferVersion 4.1.10            Encoder:                1. Change parameter type of deblock alpha/beta and chroma offset                2. Add a switch to turn on/off coefficient thresholdingVersion 4.1.11            Encoder:                1. Fix bug: return wrong slice offset when encode 1080p                2. Fix skip MB counter large than 4095Version 4.1.12            Encoder:                1. update frame rate defition (frame_time = 2 * num_units_in_tick / time_scale)                2. adaptive profile level setting                3. fix bug: when roi enable, handling skip mb counter overflow will encode error bitstreamVersion 4.1.13            Encoder:                1. add proc to force I frame encoded by better QP or fixed QP                2. add constraint of fixed QP in I frame                3. add proc to disable/enable intra MB in inter frame, and add the threshold to decide whether enable intra MB in inter frame                (only enable for platform 8126 C version)Version 4.2.1            Codec:                1. codec clock switch*///================change log===================//#define H264VER            0x00040021#define H264VER_MAJOR      ((H264VER>>16)&0xffff)#define H264VER_MINOR      ((H264VER>>4)&0xfff)#define H264VER_MINOR2     (H264VER&0x000f)/*H264VER_MAJOR means huge changeH264VER_MINOR means interface change H264VER_MINOR2 means functional modified or bug fixed*/// ioctl flag, should be consistent with driver definition#define FAVC_IOCTL_DECODE_INIT          0x4170#define FAVC_IOCTL_DECODE_FRAME         0x4172#define FAVC_IOCTL_DECODE_420_INIT      0x4174#define FAVC_IOCTL_DECODE_420_DISPSET   0x4176#define FAVC_IOCTL_DECODE_INIT_PA2      0x4178#define FAVC_IOCTL_DECODE_INIT_PB2      0x4179#define FAVC_IOCTL_DECODE_INIT_PA3      0x4185#define FAVC_IOCTL_ENCODE_INIT          0x4173#define FAVC_IOCTL_ENCODE_FRAME         0x4175#define FAVC_IOCTL_GET_SYSINFO          0x4177#define FAVC_IOCTL_ENCODE_INIT_MP4      0x417D#define FAVC_IOCTL_ENCODE_VUI           0x417F#define FAVC_IOCTL_ENCODE_INIT_WRP      0x4180#define FAVC_IOCTL_ENCODE_CROP          0x4181#define FAVC_IOCTL_ENCODE_GET_SLICEOFF 	0x4182#define FAVC_IOCTL_ENCODE_INIT_PA2      0x4183#define FAVC_IOCTL_ENCODE_INIT_PB2      0x4184#define FAVC_IOCTL_ENCODE_GET_HALFFRAME 0x4186typedef struct {	unsigned int u32API_version;	unsigned int u32FrameWidth;		// frame width, not roi width	unsigned int u32FrameHeight;	// frame height, not roi height	unsigned int num_units_in_tick;	// frame rate = time_scale /num_units_in_tick	unsigned int time_scale;	unsigned int u32IPInterval; 		// specify how many frames will produce one I-frame	unsigned int watermark_enable; //enable watermark function or not 														// 0: disable														// 1: only insert watermark at intra-mb														// 3: insert watermark at intra/inter-mb														// others: not allowed	unsigned int watermark_interval;	// valid when watermark function is enabled									// specify the interval, to insert watermark each "watermark"ed frame									// if 1: will be inserted watermark each frames									// if N: will be inserted watermark each N frames	unsigned int watermark_init_pattern;	// valid when watermark function is enabled									// to specify the initial watermark pattern	unsigned int watermark_init_interval;	// valid when watermark function is enabled									// specify the interval, to reinit with init_pattern each "watermark"ed frames									// if 1: every "watermark"ed frame with init_pattern									// if N: initial with init_pattern each N "watermark"ed frame	/**********************************************************************************************/	// The additional parameters for Region Of Interest feature	/**********************************************************************************************/	int bROIEnable;	// To enable the function of encoding rectangular region of interest(ROI) within captured frame.								// if 1: To enable the function of encoding rectangular region of interest.								//		u32ROIX , u32ROIY, u32ROIWidth and u32ROIHeight are valid.								// if 0: To disable the function of encoding rectangular region of interest.								// others: not allowed	unsigned int u32ROIX;	// to specify the upper-left x coordinate of roi	unsigned int u32ROIY;	// to specify the upper-left y coordinate of roi	unsigned int u32ROIWidth;		// to specify the width of roi	unsigned int u32ROIHeight;	// to specify the height of roi	unsigned int mb_row_per_slice;		// specify how many mb row in one slice (max)							// 	-1: Force one frame as one slice							//	0 : if decide slice no. in one frame internally							//	> 0 ,means the number of MB_Row per slice							//	Warning:							//	  causing bitstream error when the following conditions:							//	   1. NOT set mb_row_per_slice with 0							//	   2. Total MB no. of encoded slice over (or equal to) 4096							//	   3. any 2 conjunctional frame are identical.	unsigned int img_fmt;	// 0: 2D format, CbCr interleave, named H264_2D							// 1: 2D format, CbCr non-interleave, named MP4_2D							// 2: 1D format, YUV420 planar, named RASTER_SCAN_420							// 3: 1D format, YUV420 packed, named RASTER_SCAN_422							// others: not allowed								unsigned int MaxWidth; 	unsigned int MaxHeight; 	unsigned int MaxSlice;	unsigned int FWD_Mode;//1:Encode No FWD Bitstream							//2:Encode 2x FWD Bitstream							//4:Encode 4x FWD Bitstream							// others: not allowed}FAVC_ENC_PARAM;typedef struct {	unsigned int MBRowOL;		// Overlap MB row between slices													// 0: no overlap, deault													// 1: overlap one mb row between slices													// others: not allowed	unsigned int reserved1; // reserved, must be zeros	unsigned int reserved2; // reserved, must be zeros	unsigned int reserved3; // reserved, must be zeros}FAVC_ENC_PARAM_A2;typedef struct {    unsigned int bDiv2Frame;    // Encode spatial top and bottom field separately                                // 0: encode one frame                                // 1: divide one frame to 2 frames                                // others: not allowed    unsigned int bNotVUIFullRange; // Set vui full range flag    unsigned int reserved2;    unsigned int reserved3;}FAVC_ENC_PARAM_B2;typedef struct {	unsigned int u32Quant; // To specify the quantization value.		int ForceNonRef;			// [when in]							// specify this P frame not to be reference. skip this when current frame is I-frame							// 1: Force this P frame not to be reference							// 0: Force this P frame to be reference							// -1:let encoder decide, reference to FWD_Mode parameter.							// [when out]							// 1: current P frame was encoded as non-referenced 							// 0: current P frame was encoded as referenced.	int ssp_output;   //This variable tells the H.264 must be encoded out sps + pps before slice data.					// 1 : force the encoder to output SPS+PPS on first slice each frame					// 0 : force the encoder to output SPS+PPS on first Slice of IDR frame					// -1: force the encoder to output SPS+PPS on first frame only.					// -2 : force the encoder to output SPS+PPS on any Slice of IDR frame	int intra;			// [when in]							// specify which kind of frame you wnat to.							// 1: forces the encoder  to create a keyframe.							// 0:  forces the  encoder not to  create a keyframe.							// -1: let the encoder decide (based on contents and u32IPInterval). 							// [when out]							// 1: current frame is a keyframe.							// 0: current frame is not a keyframe.		unsigned char *pu8YFrameBaseAddr;  // The base address for input Y frame buffer.										// This variable can be used both in MPEG 2D mode and H.264 2D mode.										// the input frame buffer address must be vertual address  with 8-byte aligned		unsigned char *pu8UVFrameBaseAddr; // The base address for input UV frame buffer.										// This variable is used only in H.264 2D mode.										// the input frame buffer address must be vertual address  with 8-byte aligned	unsigned char *pu8UFrameBaseAddr;  // The base address for input U frame buffer.										//This variable is used only in MPEG 2D mode.										// the input frame buffer address must be vertual address  with 8-byte aligned	unsigned char *pu8VFrameBaseAddr; // The base address for input V frame buffer.										// This variable is used only in MPEG 2D mode.	                                    // the input frame buffer address must be vertual address  with 8-byte aligned	unsigned int bitstream_size;	unsigned char * bitstream;   	int frame_cost;}FAVC_ENC_FRAME;typedef struct {	unsigned int max_slice_no;	// [when in]															// To specify the buffer size (unit: int) for slice offset.															// max: 256															// [when out]															// Indicate how many slice offset will be show at slice_offset[].	int slice_offset[256];			// the real offset will be located between (n, n+8],															// where n is slice_offset[0 ~ 255]} FAVC_ENC_SLICE_OFF;typedef struct {    unsigned int u32HalfFrameOffset[2];} FAVC_ENC_HALF_FRAME_OFF;typedef struct {	unsigned int u32API_version;	unsigned int u32MaxWidth;	unsigned int u32MaxHeight;	unsigned int u32FrameBufferWidth;	unsigned int u32FrameBufferHeight;	unsigned int output_fmt;} FAVC_DEC_PARAM;typedef struct {	unsigned int MaxSliceNo;	// valid for DeVideoHeight_step_disp not equal to 0												//0: auto set to 1	unsigned int reserved1;			// reserved, must be zeros	unsigned int reserved2;			// reserved, must be zeros	unsigned int reserved3;			// reserved, must be zeros} FAVC_DEC_PARAM_B2;typedef struct {	unsigned int DeVideoHeight_step;	unsigned int DeVideoHeight;	// total decode video height each frame at least(16 multiple)													// 0: equal to video_height													// other: specify the height	unsigned int reserved2; 		// reserved, must be zeros	unsigned int reserved3; 		// reserved, must be zeros} FAVC_DEC_PARAM_A2;typedef struct {    unsigned int bHalfFrameMode;    // half frame mode    unsigned int bDecode2Frame;     // one bitstream caontain 2 frame    unsigned int u32FrameStrideAP;  // frame width from AP mmap    unsigned int u32FrameHeightAP;  // frame height from AP mmap} FAVC_DEC_PARAM_A3;typedef struct {	unsigned int u32Pkt_size;	unsigned int pu8Pkt_buf;	unsigned int pu8Display_addr[3];} FAVC_DEC_FRAME;typedef struct {	unsigned int bEndOfDec;	unsigned int u32Width;	unsigned int u32Height;	unsigned int u32UsedBytes;	unsigned int u32FrameNum;	unsigned int u32OrgHeight;	unsigned int reserved0;	unsigned int reserved1;	int isDisplayOut;	int isISlice;} FAVC_DEC_RESULT;typedef struct{	unsigned int crop_x;	// pixel unit: crop x start point at decoded-frame	unsigned int crop_y;	// pixel unit: crop y start point at decoded-frame} FAVC_DEC_Crop;typedef struct {	unsigned int  video_format;	unsigned char colour_description_present_flag;	unsigned int  colour_primaries;	unsigned int  transfer_characteristics;	unsigned int  matrix_coefficients;	unsigned char chroma_location_info_present_flag;	unsigned int  chroma_sample_loc_type_top_field;	unsigned int  chroma_sample_loc_type_bottom_field;	unsigned int  sar_width;	unsigned int  sar_height;} FAVC_VUI_PARAM ;typedef struct {	unsigned int left_offset;	unsigned int right_offset;	unsigned int top_offset;	unsigned int buttom_offset;} FAVC_CROP_PARAM;#endif //__IOCTL_H264_H_